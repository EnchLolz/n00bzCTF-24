# EVM - Conditions

Category: BLOCKCHAIN

Points: xxx

Solves: xxx

>So much maths... You need to find the value, in hex, that you need to send to make the contract STOP and not self destruct. Wrap the hex in n00bz{}.

### Solution

We are given some longer bytecode this time `5f600f607002610258525f60056096046090525f600760090A61FFFA526105396126aa18620bfabf52600361fffa5102620bfabf51013461025851600402016090510114604857ff00` and we can disassemble it with https://app.dedaub.com/decompile giving us:

```
    0x0: PUSH0     
    0x1: PUSH1     0xf
    0x3: PUSH1     0x70
    0x5: MUL       
    0x6: PUSH2     0x258
    0x9: MSTORE    
    0xa: PUSH0     
    0xb: PUSH1     0x5
    0xd: PUSH1     0x96
    0xf: DIV       
   0x10: PUSH1     0x90
   0x12: MSTORE    
   0x13: PUSH0     
   0x14: PUSH1     0x7
   0x16: PUSH1     0x9
   0x18: EXP       
   0x19: PUSH2     0xfffa
   0x1c: MSTORE    
   0x1d: PUSH2     0x539
   0x20: PUSH2     0x26aa
   0x23: XOR       
   0x24: PUSH3     0xbfabf
   0x28: MSTORE    
   0x29: PUSH1     0x3
   0x2b: PUSH2     0xfffa
   0x2e: MLOAD     
   0x2f: MUL       
   0x30: PUSH3     0xbfabf
   0x34: MLOAD     
   0x35: ADD       
   0x36: CALLVALUE 
   0x37: PUSH2     0x258
   0x3a: MLOAD     
   0x3b: PUSH1     0x4
   0x3d: MUL       
   0x3e: ADD       
   0x3f: PUSH1     0x90
   0x41: MLOAD     
   0x42: ADD       
   0x43: EQ        
   0x44: PUSH1     0x48
   0x46: JUMPI     
   0x47: SELFDESTRUCT
   0x48: STOP         
```

We can go through this line by line to see what we are doing:
1. `0x0: PUSH0` does nothing
2. `0x1: PUSH1 0xf` pushes 0xf onto the stack. stack [ 0xf ] memory { }
3. `0x3: PUSH1 0x70` pushes 0x70 onto the stack. stack [ 0xf | 0x70 ] memory { }
4. `0x5: MUL` multiplies top 2 values of stack. stack [ 0x690 ] memory { }
5. `0x6: PUSH2 0x258` pushes 0x258 onto the stack. stack [ 0x690 |  0x258 ] memory { }
6. `0x9: MSTORE` stores 2nd value at location top value in memory. stack [ ] memory { 0x258:0x690 }
7. `0xa: PUSH0` does nothing
8. `0xb: PUSH1 0x5` pushes 0x5 onto the stack. stack [ 0x5 ] memory { 0x258:0x690 }
9. `0xd: PUSH1 0x96` pushes 0x96 onto the stack. stack [ 0x5 | 0x96 ] memory { 0x258:0x690 }
10. `0xf: DIV` divides top value by 2nd value in stack. stack [ 0x1e ] memory { 0x258:0x690 }
11. `0x10: PUSH1 0x90` pushes 0x90 onto the stack. stack [ 0x1e | 0x90 ] memory { 0x258:0x690 }
12. `0x12: MSTORE` store 2nd value at top value in memory. stack [ ] memory { 0x258:0x690 , 0x90:0x1e}
13. `0x13: PUSH0` does nothing
14. `0x14: PUSH1 0x7` pushes 0x7 onto the stack. stack [ 0x7 ] memory { 0x258:0x690 , 0x90:0x1e}
15. `0x16: PUSH1 0x9` pushes 0x9 onto the stack. stack [ 0x7 | 0x9 ] memory { 0x258:0x690 , 0x90:0x1e}
16. `0x18: EXP` exponentiates top value with 2nd value (9^7). stack [ 0x48fb79 ] memory { 0x258:0x690 , 0x90:0x1e}
17. `0x19: PUSH2 0xfffa` pushes 0xfffa onto the stack. stack [ 0x48fb79 | 0xfffa ] memory { 0x258:0x690 , 0x90:0x1e}
18. `0x1c: MSTORE` stores 2nd value at top value in memory. stack [ ] memory { 0x258:0x690 , 0x90:0x1e , 0xfffa:0x48fb79 }
19. `0x1d: PUSH2 0x539` pushes 0x539 onto the stack. stack [ 0x539 ] memory { 0x258:0x690 , 0x90:0x1e , 0xfffa:0x48fb79 }
20. `0x20: PUSH2 0x26aa` pushes 0x26aa onto the stack. stack [ 0x539 | 0x26aa ] memory { 0x258:0x690 , 0x90:0x1e , 0xfffa:0x48fb79 }
21. `0x23: XOR` xores top two values of stack. stack [ 0x2393 ] memory { 0x258:0x690 , 0x90:0x1e , 0xfffa:0x48fb79 }
22. `0x24: PUSH3 0xbfabf` pushes 0xbfabf onto stack. stack [ 0x2393 | 0xbfabf ] memory { 0x258:0x690 , 0x90:0x1e , 0xfffa:0x48fb79 }
23. `0x28: MSTORE` stores 2nd value at top value in memory. stack [ ] memory { 0x258:0x690 , 0x90:0x1e , 0xfffa:0x48fb79 , 0xbfabf:0x2393 }
24. `0x29: PUSH1 0x3` pushes 0x3 onto stack. stack [ 0x3 ] memory { 0x258:0x690 , 0x90:0x1e , 0xfffa:0x48fb79 , 0xbfabf:0x2393 }
25. `0x2b: PUSH2 0xfffa` pushes 0xfffa onto stack. stack [ 0x3 | 0xfffa ] memory { 0x258:0x690 , 0x90:0x1e , 0xfffa:0x48fb79 , 0xbfabf:0x2393 }  
26. `0x2e: MLOAD` loads value from top value in stack. stack [ 0x3 | 0x48fb79 ] memory { 0x258:0x690 , 0x90:0x1e , 0xfffa:0x48fb79 , 0xbfabf:0x2393 }   
27. `0x2f: MUL` multiplies top 2 values of stack. stack [ 0xdaf26b ] memory { 0x258:0x690 , 0x90:0x1e , 0xfffa:0x48fb79 , 0xbfabf:0x2393 }   
28. `0x30: PUSH3 0xbfabf` pushes 0xbfabf onto stack. stack [ 0xdaf26b | 0xbfabf ] memory { 0x258:0x690 , 0x90:0x1e , 0xfffa:0x48fb79 , 0xbfabf:0x2393 }
29. `0x34: MLOAD` loads value from top value in stack. stack [ 0xdaf26b | 0x2393 ] memory { 0x258:0x690 , 0x90:0x1e , 0xfffa:0x48fb79 , 0xbfabf:0x2393 }
30. `0x35: ADD` adds top 2 values of stack. stack [ 0xdb15fe ] memory { 0x258:0x690 , 0x90:0x1e , 0xfffa:0x48fb79 , 0xbfabf:0x2393 }
31. `0x36: CALLVALUE` pushes user input to stack. stack [ 0xdb15fe | input ] memory { 0x258:0x690 , 0x90:0x1e , 0xfffa:0x48fb79 , 0xbfabf:0x2393 }
32. `0x37: PUSH2 0x258` pushes 0x258 onto stack. stack [ 0xdb15fe | input | 0x258 ] memory { 0x258:0x690 , 0x90:0x1e , 0xfffa:0x48fb79 , 0xbfabf:0x2393 }  
33. `0x3a: MLOAD` loads value from top value in stack. stack [ 0xdb15fe | input | 0x690 ] memory { 0x258:0x690 , 0x90:0x1e , 0xfffa:0x48fb79 , 0xbfabf:0x2393 }  
34. `0x3b: PUSH1 0x4` pushes 0x4 onto stack. stack [ 0xdb15fe | input | 0x690 | 0x4 ] memory { 0x258:0x690 , 0x90:0x1e , 0xfffa:0x48fb79 , 0xbfabf:0x2393 }  
35. `0x3d: MUL` multiplies top 2 values of stack. stack [ 0xdb15fe | input | 0x1a40 ] memory { 0x258:0x690 , 0x90:0x1e , 0xfffa:0x48fb79 , 0xbfabf:0x2393 }  
36. `0x3e: ADD` adds top 2 values of stack. stack [ 0xdb15fe | input+0x1a40 ] memory { 0x258:0x690 , 0x90:0x1e , 0xfffa:0x48fb79 , 0xbfabf:0x2393 } 
37. `0x3f: PUSH1 0x90` pushes 0x90 onto stack. stack [ 0xdb15fe | input+0x1a40 | 0x90] memory { 0x258:0x690 , 0x90:0x1e , 0xfffa:0x48fb79 , 0xbfabf:0x2393 } 
38. `0x41: MLOAD` loads value from top value in stack. stack [ 0xdb15fe | input+0x1a40 | 0x1e] memory { 0x258:0x690 , 0x90:0x1e , 0xfffa:0x48fb79 , 0xbfabf:0x2393 } 
39. `0x42: ADD` adds top 2 values of stack. stack [ 0xdb15fe | input+0x1a5e ] memory { 0x258:0x690 , 0x90:0x1e , 0xfffa:0x48fb79 , 0xbfabf:0x2393 } 
40. `0x43: EQ` check if top 2 values of stack are equal. 0xdb15fe == input+0x1a5e
41. `0x44: PUSH1 0x48` pushes 0x48 onto stack.
42. `0x46: JUMPI` jumps to 0x48 aka `STOP` if `EQ` is true
43. `0x47: SELFDESTRUCT` BAD \>\:(
44. `0x48: STOP` GOOD \:)

From this we can see that all we need to find is some `x` such that `x+0x1a5e = 0xdb15fe`. After some quick maths we get that `x = 14351264` or `0xdafba0`

*Turns out you can view the decompiled solidity code which is optimized so the challenge becomes trivial but where's the fun in that!

### Flag

```n00bz{0xdafba0}```